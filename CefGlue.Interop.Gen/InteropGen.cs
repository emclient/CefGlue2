using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;

namespace CefParser
{
    public class InteropGen
    {
        CefParser parser;
        Dictionary<string, CefParser.Class> nameToClass;
        HashSet<string> nameToIsParent;
        int targetApiVersion;

        public InteropGen(CefParser parser, int targetApiVersion = 0)
        {
            this.parser = parser;
            this.nameToClass = parser.Classes.ToDictionary(c => c.Name, StringComparer.OrdinalIgnoreCase);
            this.nameToIsParent = new HashSet<string>(parser.Classes.Select(c => c.ParentName));

            // Target the latest stable API if not specified
            this.targetApiVersion = targetApiVersion == 0 ? parser.StableApiVersion : targetApiVersion;

            if (!parser.ApiHashWindows.ContainsKey(this.targetApiVersion))
                throw new ArgumentOutOfRangeException(nameof(targetApiVersion));
        }

        string GetTopBaseClassName(CefParser.Class cls)
        {
            while (cls is not null)
            {
                if (cls.ParentName == "CefBaseRefCounted" ||
                    cls.ParentName == "CefBaseScoped")
                    return cls.ParentName;
                cls = nameToClass[cls.ParentName];
            }
            return string.Empty;
        }

        void WriteHeader(TextWriter writer)
        {
            writer.WriteLine(
                """
                //
                // DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
                //
                """);
        }

        private IEnumerable<T> FilterAndSortFunctionsByApiVersion<T>(IReadOnlyList<T> funcs)
            where T : CefParser.Function
        {
            return funcs.Where(f =>
                (f.VersionRemoved == 0 || f.VersionRemoved > targetApiVersion) &&
                (f.VersionAdded == 0 || f.VersionAdded <= targetApiVersion)).OrderBy(f => f.VersionAdded);
        }

        public void GenerateStructFile(CefParser.Class cls, TextWriter writer)
        {
            bool isHandler = cls.Attrib.Contains("source=client");

            string iname = CefParser.GetCApiName(cls.Name, true);

            WriteHeader(writer);

            writer.WriteLine("using System;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLine("using System.Security;");
            writer.WriteLine();

            writer.WriteLine("namespace Xilium.CefGlue.Interop;");
            writer.WriteLine();

            writer.WriteLine("[StructLayout(LayoutKind.Sequential, Pack = libcef.ALIGN)]");
            writer.WriteLine($"internal unsafe struct {iname}");
            writer.WriteLine("{");

            string delegateVisibility = !isHandler ? "private" : "internal";

            string parentClassName = CefParser.GetCApiName(cls.ParentName, true);

            writer.WriteLine($"\tinternal {parentClassName} _base;");

            foreach (var func in FilterAndSortFunctionsByApiVersion(cls.VirtualFunctions))
            {
                writer.Write($"\tinternal delegate * unmanaged<");
                writer.Write($"{CefParser.GetCApiName(cls.Name, true)}*");
                string cinteropArgsPrototype = func.CInteropArgsPrototype;
                if (!string.IsNullOrEmpty(cinteropArgsPrototype))
                    writer.Write($", {string.Join(", ", func.CInteropArgs.Select(a => a.Type))}");
                writer.WriteLine($", {func.ReturnType.CInteropType}> _{func.GetCApiName()};");
            }

            writer.WriteLine();

            foreach (var f in FilterAndSortFunctionsByApiVersion(cls.StaticFunctions))
            {
                writer.WriteLine($"\t// {f.Name}");
                writer.WriteLine($"\t[DllImport(libcef.DllName, EntryPoint = \"{f.GetCApiName()}\", CallingConvention = libcef.CEF_CALL)]");
                writer.WriteLine($"\tpublic static extern {f.ReturnType.CInteropType} {f.CInteropName}({f.CInteropArgsPrototype});");
                writer.WriteLine();
            }

            if (!isHandler)
            {
                foreach (var func in FilterAndSortFunctionsByApiVersion(cls.VirtualFunctions))
                {
                    writer.Write($"\tpublic static {func.ReturnType.CInteropType} {func.GetCApiName()}(");
                    writer.Write($"{CefParser.GetCApiName(cls.Name, true)}* self");
                    string cinteropArgsPrototype = func.CInteropArgsPrototype;
                    if (!string.IsNullOrEmpty(cinteropArgsPrototype))
                        writer.Write($", {cinteropArgsPrototype}");
                    writer.Write($") => self->_{func.GetCApiName()}(self");
                    if (!string.IsNullOrEmpty(cinteropArgsPrototype))
                        writer.Write($", {string.Join(", ", func.CInteropArgs.Select(a => a.Name))}");
                    writer.WriteLine(");");
                }
            }

            writer.WriteLine("}");
        }

        public void GenerateLibCefG(TextWriter writer)
        {
            WriteHeader(writer);

            writer.WriteLine("using System;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLine();

            writer.WriteLine("namespace Xilium.CefGlue.Interop;");
            writer.WriteLine();

            writer.WriteLine("internal static unsafe partial class libcef");
            writer.WriteLine("{");

            foreach (var f in FilterAndSortFunctionsByApiVersion(parser.GlobalFunctions))
            {
                string csnName = f.GetCApiName();
                if (csnName.StartsWith("cef_"))
                    csnName = csnName[4..];
                writer.WriteLine($"\t// {f.Name}");
                writer.WriteLine($"\t[DllImport(libcef.DllName, EntryPoint = \"{f.GetCApiName()}\", CallingConvention = libcef.CEF_CALL)]");
                writer.WriteLine($"\tpublic static extern {f.ReturnType.CInteropType} {csnName}({f.CInteropArgsPrototype});");
                writer.WriteLine();
            }

            writer.WriteLine("}");
        }

        private void WriteComment(TextWriter writer, string[] comment, string prefix)
        {
            writer.WriteLine($"{prefix}/// <summary>");
            foreach (var commentLine in comment.Skip(1).Take(comment.Length - 2))
                writer.WriteLine($"{prefix}///{commentLine}");
            writer.WriteLine($"{prefix}/// </summary>");
        }

        private bool IsByValueStruct(string csharpName)
        {
            return csharpName
                is "CefBaseTime"
                or "CefColor"
                or "CefCompositionUnderline"
                or "CefDraggableRegion"
                or "CefInsets"
                or "CefKeyEvent"
                or "CefMainArgs"
                or "CefMediaSinkDeviceInfo"
                or "CefMouseEvent"
                or "CefPoint"
                or "CefRange"
                or "CefRectangle"
                or "CefSettings"
                or "CefSize"
                or "CefTime"
                or "CefTouchEvent"
                or "CefUrlParts";
        }

        private void WriteUnmanagedToManagedMethod(TextWriter writer, CefParser.Class cls, CefParser.Function func)
        {
            List<string> argNames = new List<string>();
            List<string> csArgs = new List<string>();
            string csRetType = "void";
            string csFuncName;

            // Generate conversion method
            writer.WriteLine($"\t[UnmanagedCallersOnly]");
            writer.Write($"\tprivate static {func.ReturnType.CInteropType} {func.GetCApiName()}_unmanaged(");
            writer.Write($"{CefParser.GetCApiName(cls.Name, true)}* self");
            string cintropArgsPrototype = func.CInteropArgsPrototype;
            if (!string.IsNullOrEmpty(cintropArgsPrototype))
                writer.Write($", {cintropArgsPrototype}");
            writer.WriteLine(")");
            writer.WriteLine("\t{");
            writer.WriteLine("\t\tvar _this = FromNativeNoRelease(self);");
            
            foreach (var arg in func.Arguments)
            {
                var csharpType = arg.Type.CSharpType;
                var argName = NameConverter.CInteropToCSharp(arg.Name, startSmall: true);
                var quotedArgName = NameConverter.QuoteName(argName);
                var quotedInteropArgName = NameConverter.QuoteName(arg.Name);

                switch (arg.Type.ArgumentClass)
                {
                    case CefParser.ArgClass.SimpleByVal:
                        argNames.Add(quotedInteropArgName);
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.SimpleByRef:
                    case CefParser.ArgClass.SimpleByAddr:
                        if (csharpType is "IntPtr")
                        {
                            argNames.Add($"(IntPtr){quotedInteropArgName}");
                            csArgs.Add($"{csharpType} {quotedArgName}");
                        }
                        else
                        {
                            writer.WriteLine($"\t\tvar _{argName} = {quotedInteropArgName} != null ? *{quotedInteropArgName} : default;");
                            argNames.Add($"ref _{argName}");
                            csArgs.Add($"{csharpType} {quotedArgName}");
                        }
                        break;

                    case CefParser.ArgClass.SimpleByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = {quotedInteropArgName} != null ? *{quotedInteropArgName} : default;");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.BoolByVal:
                        writer.WriteLine($"\t\tvar _{argName} = {quotedInteropArgName} == 0 ? false : true;");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.BoolByRef:
                    case CefParser.ArgClass.BoolByAddr:
                        writer.WriteLine($"\t\tvar _{argName} = {quotedInteropArgName} != null && *{quotedInteropArgName} != 0 ? true : false;");
                        argNames.Add($"ref _{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StructByRef:
                        writer.WriteLine($"\t\tvar _{argName} = {csharpType}.FromNative({quotedInteropArgName});");
                        if (IsByValueStruct(csharpType))
                        {
                            argNames.Add($"ref _{argName}");
                            csArgs.Add($"ref {csharpType} {quotedArgName}");
                        }
                        else
                        {
                            argNames.Add($"_{argName}");
                            csArgs.Add($"{csharpType} {quotedArgName}");
                        }
                        break;

                    case CefParser.ArgClass.StructByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = {csharpType}.FromNative({quotedInteropArgName});");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = cef_string_t.ToString({quotedInteropArgName});");
                        if (!arg.IsOptional)
                            writer.WriteLine($"\t\tArgumentNullException.ThrowIfNull(_{argName}, nameof({quotedInteropArgName}));");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType}{(arg.IsOptional ? "?" : "")} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringByRef:
                        writer.WriteLine($"\t\tvar _{argName} = cef_string_t.ToString({quotedInteropArgName});");
                        argNames.Add($"ref _{argName}");
                        csArgs.Add($"{csharpType}? {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringUserFree:
                        // Should not happen
                        Debug.Fail("cef_string_userfree should not appear in parameters");
                        break;

                    case CefParser.ArgClass.RefPtr:
                        var clsRef = nameToClass[csharpType];
                        bool argIsHandler = clsRef.Attrib.Contains("source=client");
                        bool shouldDispose = !argIsHandler && GetTopBaseClassName(clsRef) == "CefBaseRefCounted";
                        if (argName.Contains("callback") || argName.Contains("Callback"))
                            shouldDispose = false;
                        // TODO: Should we make exceptions for long-lived objects like CefFrame?
                        if (csharpType is "CefFrame" or "CefRequest" or "CefBrowser" or "CefProcessMessage" or "CefRequest" or "CefResponse" or "CefCookie" or "CefExtension")
                            shouldDispose = false;

                        string orNull = arg.IsOptional ? "OrNull" : "";
                        if (shouldDispose)
                            writer.WriteLine($"\t\tusing var _{argName} = {csharpType}.FromNative{orNull}({quotedInteropArgName});");
                        else
                            writer.WriteLine($"\t\tvar _{argName} = {csharpType}.FromNative{orNull}({quotedInteropArgName});");

                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType}{(arg.IsOptional ? "?" : "")} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.RefPtrByRef:
                        //orNull = arg.IsOptional ? "OrNull" : "";
                        writer.WriteLine($"\t\tvar _{argName} = {csharpType[4..]}.FromNativeOrNull(*{quotedInteropArgName});");
                        argNames.Add($"ref _{argName}");
                        csArgs.Add($"{csharpType}? {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringVecByRef:
                        writer.WriteLine($"\t\tvar _{argName} = cef_string_list.ToArray({quotedInteropArgName});");
                        argNames.Add($"ref _{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringVecByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = cef_string_list.ToArray({quotedInteropArgName});");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StringMapSingleByRef:
                    case CefParser.ArgClass.StringMapSingleByRefConst:
                    case CefParser.ArgClass.StringMapMultiByRef:
                    case CefParser.ArgClass.StringMapMultiByRefConst:
                        // TODO
                        throw new NotImplementedException();

                    case CefParser.ArgClass.SimpleVecByRef:
                    case CefParser.ArgClass.BoolVecByRef:
                    case CefParser.ArgClass.RefPtrVecByRef:
                    case CefParser.ArgClass.StructVecByRef:
                        // TODO
                        throw new NotImplementedException();

                    case CefParser.ArgClass.BoolVecByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = new {csharpType[..^2]}[{arg.Name}_count];");
                        writer.WriteLine($"\t\tfor (int i = 0; i < (int){arg.Name}_count; i++) _{argName}[i] = {quotedInteropArgName}[i] == 0 ? false : true;");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.SimpleVecByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = new {csharpType[..^2]}[{arg.Name}_count];");
                        writer.WriteLine($"\t\tfor (int i = 0; i < (int){arg.Name}_count; i++) _{argName}[i] = {quotedInteropArgName}[i];");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.RefPtrVecByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = new {csharpType[..^2]}[{arg.Name}_count];");
                        writer.WriteLine($"\t\tfor (int i = 0; i < (int){arg.Name}_count; i++) _{argName}[i] = {csharpType[..^2]}.FromNative({quotedInteropArgName}[i]);");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;

                    case CefParser.ArgClass.StructVecByRefConst:
                        writer.WriteLine($"\t\tvar _{argName} = new {csharpType[..^2]}[{arg.Name}_count];");
                        writer.WriteLine($"\t\tfor (int i = 0; i < (int){arg.Name}_count; i++) _{argName}[i] = {csharpType[..^2]}.FromNative({quotedInteropArgName} + i);");
                        argNames.Add($"_{argName}");
                        csArgs.Add($"{csharpType} {quotedArgName}");
                        break;
                }
            }

            // Call the C# method
            writer.Write($"\t\t");
            if (func.ReturnType.CInteropType != "void")
                writer.Write("var result = ");
            csFuncName = NameConverter.CInteropToCSharp(func.GetCApiName());
            writer.WriteLine($"_this.{csFuncName}({string.Join(", ", argNames)});");

            foreach (var arg in func.Arguments)
            {
                if (arg.Type.ArgumentClass
                    is CefParser.ArgClass.SimpleByRef
                    or CefParser.ArgClass.SimpleByAddr
                    or CefParser.ArgClass.BoolByRef
                    or CefParser.ArgClass.BoolByAddr
                    or CefParser.ArgClass.StructByRef
                    or CefParser.ArgClass.StringByRef
                    or CefParser.ArgClass.RefPtrByRef
                    or CefParser.ArgClass.StringVecByRef
                    or CefParser.ArgClass.StringMapSingleByRef
                    or CefParser.ArgClass.StringMapMultiByRef
                    or CefParser.ArgClass.SimpleVecByRef
                    or CefParser.ArgClass.BoolVecByRef
                    or CefParser.ArgClass.RefPtrVecByRef
                    or CefParser.ArgClass.StructVecByRef)
                {
                    var argName = NameConverter.CInteropToCSharp(arg.Name, startSmall: true);
                    var quotedArgName = NameConverter.QuoteName(argName);
                    var quotedInteropArgName = NameConverter.QuoteName(arg.Name);
                    
                    // Marshal return value
                    switch (arg.Type.ArgumentClass)
                    {
                        case CefParser.ArgClass.StructByRef:
                            if (IsByValueStruct(arg.Type.CSharpType))
                                writer.WriteLine($"\t\t*{quotedInteropArgName} = _{argName}.ToNative();");
                            break;

                        case CefParser.ArgClass.StringByRef:
                            writer.WriteLine($"\t\tcef_string_t.Copy(_{argName}, {quotedInteropArgName});");
                            break;

                        case CefParser.ArgClass.RefPtrByRef:
                            // TODO: Check ref counting
                            writer.WriteLine($"\t\t*{quotedInteropArgName} = _{argName} is not null ? _{argName}.ToNative() : null;");
                            break;

                        case CefParser.ArgClass.StringVecByRef:
                            writer.WriteLine($"\t\tlibcef.string_list_clear({quotedInteropArgName});");
                            writer.WriteLine($"\t\tcef_string_list.AppendTo({quotedInteropArgName}, _{argName});");
                            break;

                        case CefParser.ArgClass.SimpleByAddr:
                        case CefParser.ArgClass.SimpleByRef:
                            if (arg.Type.CSharpType is "IntPtr")
                            {
                                break;
                            }
                            writer.WriteLine($"\t\tif ({quotedInteropArgName} != null) *{quotedInteropArgName} = _{argName};");
                            break;

                        case CefParser.ArgClass.BoolByRef:
                        case CefParser.ArgClass.BoolByAddr:
                            writer.WriteLine($"\t\tif ({quotedInteropArgName} != null) *{quotedInteropArgName} = _{argName} ? 1 : 0;");
                            break;

                        default:
                            throw new NotImplementedException();
                    }
                }
            }

            if (func.ReturnType.CInteropType != "void")
            {
                var retType = func.ReturnType;
                csRetType = retType.CSharpType;
                switch (retType.ArgumentClass)
                {
                    case CefParser.ArgClass.RefPtr:
                        writer.WriteLine("\t\treturn result != null ? result.ToNative() : null;");
                        csRetType = $"{csRetType}?";
                        break;
                    case CefParser.ArgClass.BoolByVal:
                        writer.WriteLine("\t\treturn result ? 1 : 0;");
                        break;
                    case CefParser.ArgClass.StructByVal:
                        writer.WriteLine("\t\treturn result.ToNative();");
                        break;
                    case CefParser.ArgClass.SimpleByVal:
                        writer.WriteLine("\t\treturn result;");
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            writer.WriteLine("\t}");
            writer.WriteLine();

            // Generate C# native method

            // Skip generating few special methods which use Stream parameters
            bool writePartial = cls.Name switch
            {
                "CefReadHandler" when func.Name is "Read" => true,
                "CefResourceHandler" when func.Name is "Read" or "ReadResponse" => true,
                "CefResponseFilter" when func.Name is "Filter" => true,
                "CefWriteHandler" when func.Name is "Write" => true,
                _ => false
            };

            WriteComment(writer, func.Comment, "\t");
            if (writePartial)
            {
                writer.WriteLine($"\tprivate partial {csRetType} {csFuncName}({string.Join(", ", csArgs)});");
            }
            else
            {
                bool isAbstract = func is CefParser.VirtualFunction { IsAbstract: true };
                string returnValue = func.DefaultReturnValue switch {
                    "RV_CONTINUE" => "CefReturnValue.Continue",
                    _ => "default"
                };
                writer.WriteLine($"\tprotected {(isAbstract ? "abstract" : "virtual")} {csRetType} {csFuncName}({string.Join(", ", csArgs)}){(isAbstract ? ";" : (csRetType == "void" ? " { }" : " => " + returnValue + ";"))}");
            }
        }

        private bool TryWriteManagedToUnmanagedMethod(TextWriter writer, CefParser.Class cls, CefParser.Function func)
        {
            string selfPath = "GetSelf()";
            string iname = CefParser.GetCApiName(cls.Name, true);
            bool isProperty =
                func.Arguments.Count == 0 &&
                (func.Name.StartsWith("Is") || func.Name.StartsWith("Get") || func.Name.StartsWith("Can") || func.Name.StartsWith("Has") || func.Name.StartsWith("In")) &&
                func.ReturnType.ArgumentClass
                is CefParser.ArgClass.SimpleByVal
                or CefParser.ArgClass.SimpleByAddr
                or CefParser.ArgClass.StringUserFree
                or CefParser.ArgClass.BoolByVal &&
                func.ReturnType.CInteropType is not "void";
            bool isCreateOrCopy = func.Name.StartsWith("Create") || func.Name.StartsWith("Copy");
            string csFuncName = NameConverter.ToCSharpMethodName(func.Name);

            WriteComment(writer, func.Comment, "\t");
            if (isProperty)
            {
                string propertyName = csFuncName;
                if (propertyName.StartsWith("Get"))
                    propertyName = propertyName[3..];
                writer.WriteLine($"\tpublic {func.ReturnType.CSharpType} {propertyName} {{ get");
            }
            else if (func is not CefParser.StaticFunction &&
                     (func.ReturnType.CInteropType is "void" || func.ReturnType.ArgumentClass is CefParser.ArgClass.BoolByVal) &&
                     func.Arguments.Count == 1 &&
                     func.Arguments[0].Type.ArgumentClass == CefParser.ArgClass.StringVecByRef)
            {
                // Special case ref string[] into return value
                writer.WriteLine($"\tpublic string[] {csFuncName}()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tvar result = libcef.string_list_alloc();");
                // TODO: bool ret
                writer.WriteLine($"\t\t{iname}.{func.GetCApiName()}({selfPath}, result);");
                writer.WriteLine($"\t\treturn cef_string_list.ToArrayAndFree(result);");
                writer.WriteLine("\t}");
                return true;
            }
            else if (func is not CefParser.StaticFunction &&
                     func.ReturnType.CInteropType is "void" &&
                     func.Arguments.Count == 1 &&
                     func.Arguments[0].Type.ArgumentClass == CefParser.ArgClass.StringMapSingleByRef)
            {
                // Special case string map into return value
                writer.WriteLine($"\tpublic IReadOnlyDictionary<string, string> {csFuncName}()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tvar result = libcef.string_map_alloc();");
                writer.WriteLine($"\t\t{iname}.{func.GetCApiName()}({selfPath}, result);");
                writer.WriteLine($"\t\treturn cef_string_map.ToDictionaryAndFree(result);");
                writer.WriteLine("\t}");
                return true;
            }
            else if (func is not CefParser.StaticFunction &&
                     func.ReturnType.CInteropType is "void" &&
                     func.Arguments.Count == 1 &&
                     func.Arguments[0].Type.ArgumentClass == CefParser.ArgClass.StringMapMultiByRef)
            {
                // Special case string map into return value
                writer.WriteLine($"\tpublic NameValueCollection {csFuncName}()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tvar result = libcef.string_multimap_alloc();");
                writer.WriteLine($"\t\t{iname}.{func.GetCApiName()}({selfPath}, result);");
                writer.WriteLine($"\t\treturn cef_string_multimap.ToNameValueCollectionAndFree(result);");
                writer.WriteLine("\t}");
                return true;
            }
            else
            {
                var csArgs = func.Arguments.Select(a => $"{a.Type.CSharpType}{a.CSharpOptionalSuffix} {NameConverter.QuoteName(NameConverter.CInteropToCSharp(a.Name, startSmall: true))}");
                var csRetOpt = func.ReturnType.ArgumentClass is CefParser.ArgClass.RefPtr or CefParser.ArgClass.StringUserFree && !isCreateOrCopy ? "?" : "";
                writer.WriteLine($"\tpublic {(func is CefParser.StaticFunction ? "static " : "")}{func.ReturnType.CSharpType}{csRetOpt} {csFuncName}({string.Join(", ", csArgs)})");
            }

            writer.WriteLine("\t{");

            List<string> cinteropArgs = new List<string>();
            List<string> lateInit = new();
            List<string> cleanup = new();
            bool usedFixed = false;
            foreach (var arg in func.Arguments)
            {
                var csharpType = arg.Type.CSharpType;
                var argName = NameConverter.CInteropToCSharp(arg.Name, startSmall: true);
                var quotedArgName = NameConverter.QuoteName(argName);
                var quotedInteropArgName = NameConverter.QuoteName(arg.Name);

                switch (arg.Type.ArgumentClass)
                {
                    case CefParser.ArgClass.SimpleByVal:
                        cinteropArgs.Add(quotedArgName);
                        break;

                    case CefParser.ArgClass.StructByVal:
                        if (csharpType is "CefBaseTime" or "CefTime")
                        {
                            cinteropArgs.Add(quotedArgName);
                        }
                        else
                        {
                            return false;
                        }
                        break;

                    case CefParser.ArgClass.SimpleByRef:
                    case CefParser.ArgClass.SimpleByAddr:
                        if (csharpType is "IntPtr")
                        {
                            cinteropArgs.Add($"({arg.Type.CInteropType}){quotedArgName}");
                        }
                        else
                        {
                            lateInit.Add($"var _{argName} = {argName};");
                            cleanup.Add($"{argName} = _{argName};");
                            cinteropArgs.Add($"&_{argName}");
                        }
                        break;

                    case CefParser.ArgClass.SimpleByRefConst:
                        return false;

                    case CefParser.ArgClass.BoolByVal:
                        cinteropArgs.Add($"{quotedArgName} ? 1 : 0");
                        break;

                    case CefParser.ArgClass.BoolByRef:
                    case CefParser.ArgClass.BoolByAddr:
                        lateInit.Add($"int _{argName} = {quotedArgName} ? 1 : 0;");
                        cleanup.Add($"{argName} = _{argName} == 0 ? false : true;");
                        cinteropArgs.Add($"&_{argName}");
                        break;

                    case CefParser.ArgClass.StructByRef:
                        if (IsByValueStruct(arg.Type.CSharpType))
                        {
                            lateInit.Add($"var _{argName} = {quotedArgName}.ToNative();");
                            cleanup.Add($"{argName} = {arg.Type.CSharpType}.FromNative(&_{argName});");
                            cinteropArgs.Add($"&_{argName}");
                        }
                        else
                        {
                            return false;
                        }
                        break;

                    case CefParser.ArgClass.StructByRefConst:
                        lateInit.Add($"var _{argName} = {quotedArgName}.ToNative();");
                        if (arg.Type.CInteropType is "cef_pdf_print_settings_t*" or "cef_request_context_settings_t*")
                            cleanup.Add($"{arg.Type.CInteropType[..^1]}.Clear(_{argName});");
                        if (IsByValueStruct(csharpType))
                        {
                            cinteropArgs.Add($"&_{argName}");
                        }
                        else
                        {
                            cleanup.Add($"{arg.Type.CInteropType[..^1]}.Free(_{argName});");
                            cinteropArgs.Add($"_{argName}");
                        }
                        break;

                    case CefParser.ArgClass.StringByRefConst:
                        usedFixed = true;
                        writer.WriteLine($"\t\tfixed (char* _{argName} = {quotedArgName})");
                        lateInit.Add($"cef_string_t __{argName} = new cef_string_t(_{argName}, {quotedArgName} is not null ? {quotedArgName}.Length : 0);");
                        cinteropArgs.Add($"&__{argName}");
                        break;

                    case CefParser.ArgClass.StringByRef:
                        writer.WriteLine($"\t\tfixed (char* _{argName} = {quotedArgName})");
                        lateInit.Add($"cef_string_t __{argName} = new cef_string_t(_{argName}, {quotedArgName} is not null ? {quotedArgName}.Length : 0);");
                        cleanup.Add($"{argName} = cef_string_t.ToString(&__{argName});");
                        cinteropArgs.Add($"&__{argName}");
                        break;

                    case CefParser.ArgClass.StringUserFree:
                        // Should not happen
                        Debug.Fail("cef_string_userfree should not appear in parameters");
                        break;

                    case CefParser.ArgClass.RefPtr:
                        if (csharpType is "CefBaseRefCounted")
                            return false;
                        if (arg.IsOptional)
                            cinteropArgs.Add($"{quotedArgName} is not null ? {quotedArgName}.ToNative() : null");
                        else
                            cinteropArgs.Add($"{quotedArgName}.ToNative()");
                        break;

                    case CefParser.ArgClass.RefPtrByRef:
                        lateInit.Add($"{arg.Type.CInteropType[..^1]} _{argName} = {quotedArgName} is not null ? {quotedArgName}.ToNative() : null;");
                        cleanup.Add($"{argName} = {csharpType[4..]}.FromNativeOrNull(_{argName});");
                        cinteropArgs.Add($"&_{argName}");
                        break;

                    case CefParser.ArgClass.StringVecByRef:
                        return false;

                    case CefParser.ArgClass.StringVecByRefConst:
                        lateInit.Add($"var _{argName} = cef_string_list.From({quotedArgName});");
                        cleanup.Add($"libcef.string_list_free(_{argName});");
                        cinteropArgs.Add($"_{argName}");
                        break;

                    case CefParser.ArgClass.StringMapSingleByRef:
                    case CefParser.ArgClass.StringMapMultiByRef:
                        return false;

                    case CefParser.ArgClass.StringMapSingleByRefConst:
                        lateInit.Add($"var _{argName} = cef_string_map.From({quotedArgName});");
                        cleanup.Add($"libcef.string_map_free(_{argName});");
                        cinteropArgs.Add($"_{argName}");
                        break;

                    case CefParser.ArgClass.StringMapMultiByRefConst:
                        lateInit.Add($"var _{argName} = cef_string_multimap.From({quotedArgName});");
                        cleanup.Add($"libcef.string_multimap_free(_{argName});");
                        cinteropArgs.Add($"_{argName}");
                        break;

                    case CefParser.ArgClass.SimpleVecByRef:
                    case CefParser.ArgClass.BoolVecByRef:
                    case CefParser.ArgClass.RefPtrVecByRef:
                    case CefParser.ArgClass.StructVecByRef:
                        return false;

                    case CefParser.ArgClass.BoolVecByRefConst:
                        return false;

                    case CefParser.ArgClass.SimpleVecByRefConst:
                        return false;

                    case CefParser.ArgClass.RefPtrVecByRefConst:
                        return false;

                    case CefParser.ArgClass.StructVecByRefConst:
                        lateInit.Add($"var _{argName}Count = (nuint)({quotedArgName} is not null ? {quotedArgName}.Length : 0);");
                        lateInit.Add($"var _{argName} = ({arg.Type.CInteropType})NativeMemory.Alloc((nuint)sizeof({arg.Type.CInteropType[..^1]}) * _{argName}Count);");
                        lateInit.Add($"for (nuint i = 0; {quotedArgName} is not null && i < _{argName}Count; i++) _{argName}[i] = {quotedArgName}[i].ToNative();");
                        cleanup.Add($"NativeMemory.Free(_{argName});");
                        cinteropArgs.Add($"_{argName}Count");
                        cinteropArgs.Add($"_{argName}");
                        break;
                }
            }

            string indent = usedFixed ? "\t\t\t" : "\t\t";
            if (usedFixed)
                writer.WriteLine("\t\t{");

            foreach (string line in lateInit)
                writer.WriteLine($"{indent}{line}");
            writer.Write($"{indent}{(func.ReturnType.CInteropType == "void" ? "" : "var result = ")}{iname}.{func.CInteropName}(");
            bool writeComma = false;
            if (func is not CefParser.StaticFunction)
            {
                writer.WriteLine();
                writer.Write($"{indent}\t{selfPath}");
                writeComma = true;
            }
            else if (cinteropArgs.Count > 0)
            {
                writer.WriteLine();
            }
            for (int i = 0; i < cinteropArgs.Count; i++)
            {
                if (i > 0 || writeComma)
                    writer.WriteLine(",");
                writer.Write($"{indent}\t{cinteropArgs[i]}");
            }
            writer.WriteLine(");");
            // TODO: try/finally
            foreach (string line in cleanup)
                writer.WriteLine($"{indent}{line}");

            if (func.ReturnType.CInteropType != "void")
            {
                var retType = func.ReturnType;
                var csRetType = retType.CSharpType;
                switch (retType.ArgumentClass)
                {
                    case CefParser.ArgClass.RefPtr:
                        if (csRetType is "CefBaseRefCounted")
                            return false;
                        if (isCreateOrCopy)
                            writer.WriteLine($"{indent}return {csRetType}.FromNative(result);");
                        else
                            writer.WriteLine($"{indent}return {csRetType}.FromNativeOrNull(result);");
                        break;
                    case CefParser.ArgClass.BoolByVal:
                        writer.WriteLine($"{indent}return result == 0 ? false : true;");
                        break;
                    case CefParser.ArgClass.StructByVal:
                        if (IsByValueStruct(csRetType))
                        {
                            if (csRetType is "CefBaseTime" or "CefTime")
                                writer.WriteLine($"{indent}return result;");
                            else
                                writer.WriteLine($"{indent}return {csRetType}.FromNative(&result);");
                        }
                        else
                        {
                            return false;
                        }
                        break;
                    case CefParser.ArgClass.SimpleByVal:
                        writer.WriteLine($"{indent}return result;");
                        break;
                    case CefParser.ArgClass.StringUserFree:
                        writer.WriteLine($"{indent}return cef_string_userfree.ToString(result);");
                        break;
                    case CefParser.ArgClass.SimpleByAddr:
                        Debug.Assert(csRetType is "IntPtr");
                        writer.WriteLine($"{indent}return (IntPtr)result;");
                        break;
                    default:
                        return false;
                }
            }


            if (usedFixed)
                writer.WriteLine("\t\t}");

            if (isProperty)
                writer.WriteLine("\t} }");
            else
                writer.WriteLine("\t}");

            return true;
        }

        public void GenerateWrapper(CefParser.Class cls, TextWriter writer)
        {
            bool isHandler = cls.Attrib.Contains("source=client");

            WriteHeader(writer);

            writer.WriteLine("using System;");
            writer.WriteLine("using System.Collections.Generic;");
            writer.WriteLine("using System.Collections.Specialized;");
            writer.WriteLine("using System.Diagnostics;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLine("using System.Threading;");
            writer.WriteLine("using Xilium.CefGlue.Interop;");
            writer.WriteLine();

            writer.WriteLine("namespace Xilium.CefGlue;");
            writer.WriteLine();

            writer.WriteLine("#nullable enable");
            writer.WriteLine();

            writer.WriteLine($"// ROLE: {(isHandler ? "HANDLER" : "PROXY")}");

            bool isRefCountedImpl = cls.ParentName is "CefBaseRefCounted";
            bool isScopedImpl = cls.ParentName is "CefBaseScoped";
            string maybeSealedModifier =  "sealed ";

            if (nameToIsParent.Contains(cls.Name))
                maybeSealedModifier = "";

            var csName = cls.Name.Replace("DOM", "Dom").Replace("SSL", "Ssl").Replace("URL", "Url");
            string iname = CefParser.GetCApiName(cls.Name, true);

            WriteComment(writer, cls.Comment, "");

            if (isHandler)
            {
                writer.WriteLine($"public abstract unsafe partial class {csName}");
                writer.WriteLine("{");

                writer.WriteLine($"\tprivate {iname}* _self;");
                writer.WriteLine();

                // ctor
                writer.WriteLine($"\tprotected {csName}()");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\t_self = ({iname}*)NativeMemory.AllocZeroed((nuint)sizeof({iname}) + (nuint)sizeof(cef_handler_block_t));");
                string basePrefix = "";
                CefParser.Class? currentCls = cls;
                do
                {
                    foreach (var func in FilterAndSortFunctionsByApiVersion(currentCls.VirtualFunctions))
                        writer.WriteLine($"\t\t_self->{basePrefix}_{func.GetCApiName()} = &{func.GetCApiName()}_unmanaged;");
                    if (nameToClass.TryGetValue(currentCls.ParentName, out currentCls))
                        basePrefix += "_base.";
                }
                while (currentCls is not null);
                writer.WriteLine($"\t\t_self->{basePrefix}_base._size = (nuint)sizeof({iname});");
                writer.WriteLine($"\t\t_self->{basePrefix}_base._add_ref = &add_ref_unmanaged;");
                writer.WriteLine($"\t\t_self->{basePrefix}_base._release = &release_unmanaged;");
                writer.WriteLine($"\t\t_self->{basePrefix}_base._has_one_ref = &has_one_ref_unmanaged;");
                writer.WriteLine($"\t\t_self->{basePrefix}_base._has_at_least_one_ref = &has_at_least_one_ref_unmanaged;");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)_self + (nuint)sizeof({iname}));");
                writer.WriteLine($"\t\tptrBlock->_refct = 0;");
                writer.WriteLine($"\t\tptrBlock->_gcHandle = GCHandle.ToIntPtr(GCHandle.Alloc(this, GCHandleType.Weak));");
                writer.WriteLine("\t}");
                writer.WriteLine();

                // finalizer & dispose
                writer.WriteLine($"\t~{csName}()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tDispose(false);");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine("\tprivate void Dispose()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tDispose(true);");
                writer.WriteLine("\t\tGC.SuppressFinalize(this);");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine("\tprotected virtual void Dispose(bool disposing)");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tif (_self != null)");
                writer.WriteLine("\t\t{");
                writer.WriteLine($"\t\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)_self + (nuint)sizeof({iname}));");
                writer.WriteLine($"\t\t\tGCHandle.FromIntPtr(ptrBlock->_gcHandle).Free();");
                writer.WriteLine($"\t\t\tNativeMemory.Free(_self);");
                writer.WriteLine($"\t\t\t_self = null;");
                writer.WriteLine("\t\t}");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tprivate static void add_ref({iname}* self)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)self + (nuint)sizeof({iname}));");
                writer.WriteLine("\t\tif (Interlocked.Increment(ref ptrBlock->_refct) == 1)");
                writer.WriteLine("\t\t{");
                writer.WriteLine("\t\t\tGCHandle _gcHandle = GCHandle.FromIntPtr(ptrBlock->_gcHandle);");
                writer.WriteLine($"\t\t\t{csName}? _this = _gcHandle.Target as {csName};");
                writer.WriteLine("\t\t\tDebug.Assert(_this is not null);");
                writer.WriteLine("\t\t\tGCHandle _newGcHandle = GCHandle.Alloc(_this, GCHandleType.Normal);");
                writer.WriteLine("\t\t\t_gcHandle.Free();");
                writer.WriteLine("\t\t\tptrBlock->_gcHandle = GCHandle.ToIntPtr(_newGcHandle);");
                writer.WriteLine("\t\t}");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\t[UnmanagedCallersOnly]");
                writer.WriteLine($"\tprivate static void add_ref_unmanaged(cef_base_ref_counted_t* self)");
                writer.WriteLine($"\t\t=> add_ref(({iname}*)self);");
                writer.WriteLine();

                writer.WriteLine($"\tprivate static int release({iname}* self)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)self + (nuint)sizeof({iname}));");
                writer.WriteLine("\t\tif (Interlocked.Decrement(ref ptrBlock->_refct) == 0)");
                writer.WriteLine("\t\t{");
                writer.WriteLine("\t\t\tGCHandle _gcHandle = GCHandle.FromIntPtr(ptrBlock->_gcHandle);");
                writer.WriteLine($"\t\t\t{csName}? _this = _gcHandle.Target as {csName};");
                writer.WriteLine("\t\t\tDebug.Assert(_this is not null);");
                // TODO: Autodispose?
                writer.WriteLine("\t\t\tGCHandle _newGcHandle = GCHandle.Alloc(_this, GCHandleType.Weak);");
                writer.WriteLine("\t\t\t_gcHandle.Free();");
                writer.WriteLine("\t\t\tptrBlock->_gcHandle = GCHandle.ToIntPtr(_newGcHandle);");
                writer.WriteLine("\t\t\treturn 1;");
                writer.WriteLine("\t\t}");
                writer.WriteLine("\t\treturn 0;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\t[UnmanagedCallersOnly]");
                writer.WriteLine($"\tprivate static int release_unmanaged(cef_base_ref_counted_t* self)");
                writer.WriteLine($"\t\t=> release(({iname}*)self);");
                writer.WriteLine();

                writer.WriteLine($"\t[UnmanagedCallersOnly]");
                writer.WriteLine($"\tprivate static int has_one_ref_unmanaged(cef_base_ref_counted_t* self)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)self + (nuint)sizeof({iname}));");
                writer.WriteLine($"\t\treturn ptrBlock->_refct == 1 ? 1 : 0;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\t[UnmanagedCallersOnly]");
                writer.WriteLine($"\tprivate static int has_at_least_one_ref_unmanaged(cef_base_ref_counted_t* self)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)self + (nuint)sizeof({iname}));");
                writer.WriteLine($"\t\treturn ptrBlock->_refct > 0 ? 1 : 0;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tprivate static {csName} FromNativeNoRelease(void* ptr)");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tDebug.Assert(ptr != null);");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)ptr + (nuint)sizeof({iname}));");
                writer.WriteLine("\t\tGCHandle _gcHandle = GCHandle.FromIntPtr(ptrBlock->_gcHandle);");
                writer.WriteLine($"\t\t{csName}? _this = _gcHandle.Target as {csName};");
                writer.WriteLine("\t\tDebug.Assert(_this is not null);");
                writer.WriteLine("\t\treturn _this;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tinternal static {csName} FromNative({iname}* ptr)");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tDebug.Assert(ptr != null);");
                writer.WriteLine($"\t\tcef_handler_block_t *ptrBlock = (cef_handler_block_t *)((nuint)ptr + (nuint)sizeof({iname}));");
                writer.WriteLine("\t\tGCHandle _gcHandle = GCHandle.FromIntPtr(ptrBlock->_gcHandle);");
                writer.WriteLine($"\t\t{csName}? _this = _gcHandle.Target as {csName};");
                writer.WriteLine("\t\tDebug.Assert(_this is not null);");
                writer.WriteLine($"\t\t// as we\'re getting the ref from the outside, it\'s our responsibility to decrement it");
                writer.WriteLine($"\t\trelease(ptr);");
                writer.WriteLine("\t\treturn _this;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tinternal static {csName}? FromNativeOrNull({iname}* ptr)");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\treturn ptr == null ? null : FromNative(ptr);");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tinternal {iname}* ToNative()");
                writer.WriteLine("\t{");
                writer.WriteLine("\t\tadd_ref(_self);");
                writer.WriteLine("\t\treturn _self;");
                writer.WriteLine("\t}");
                writer.WriteLine();

                basePrefix = "";
                currentCls = cls;
                do
                {
                    foreach (var func in FilterAndSortFunctionsByApiVersion(currentCls.VirtualFunctions))
                    {
                        writer.WriteLine();
                        WriteUnmanagedToManagedMethod(writer, currentCls, func);
                    }
                    if (nameToClass.TryGetValue(currentCls.ParentName, out currentCls))
                        basePrefix += "_base.";
                }
                while (currentCls is not null);

                writer.WriteLine("}");
            }
            else
            {
                string proxyBase;
                if (isRefCountedImpl)
                    proxyBase = " : IDisposable";
                else if (isScopedImpl)
                    proxyBase = "";
                else
                    proxyBase = $" : {cls.ParentName}";

                writer.WriteLine($"public {maybeSealedModifier}unsafe partial class {csName}{proxyBase}");
                writer.WriteLine("{");

                bool isImpl = isRefCountedImpl || isScopedImpl;
                bool isRefCounted = GetTopBaseClassName(cls) == "CefBaseRefCounted";

                var selfAccessor = !isImpl ? $"({iname}*)_self" : "_self";

                string maybeNewKeyword = !isImpl ? "new " : "";

                string privateOrProtected = maybeSealedModifier == "" ? "private protected" : "private";

                writer.WriteLine($"\tinternal static {csName} FromNative({iname}* ptr)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\treturn new {csName}(ptr);");
                writer.WriteLine("\t}");
                writer.WriteLine();

                writer.WriteLine($"\tinternal static {csName}? FromNativeOrNull({iname}* ptr)");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\tif (ptr is null) return null;");
                writer.WriteLine($"\t\treturn new {csName}(ptr);");
                writer.WriteLine("\t}");
                writer.WriteLine();

                if (isImpl)
                {
                    writer.WriteLine($"\t{privateOrProtected} {iname}* _self;");
                    writer.WriteLine();
                }

                // ctor
                writer.WriteLine($"\t{privateOrProtected} {csName}({iname}* ptr)");
                if (isImpl)
                {
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t\tArgumentNullException.ThrowIfNull(ptr);");
                    writer.WriteLine("\t\t_self = ptr;");
                    if (isRefCountedImpl)
                        writer.WriteLine("\t\tCefObjectTracker.Track(this);");
                    writer.WriteLine("\t}");
                }
                else
                {
                    writer.WriteLine($"\t\t: base(({CefParser.GetCApiName(cls.ParentName, true)}*)ptr)");
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t}");
                }

                writer.WriteLine();

                if (isRefCountedImpl)
                {
                    // IDisposable pattern
                    writer.WriteLine($"\t~{csName}()");
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t\tif (_self != null)");
                    writer.WriteLine("\t\t{");
                    writer.WriteLine("\t\t\tRelease();");
                    writer.WriteLine("\t\t\t_self = null;");
                    writer.WriteLine("\t\t}");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    writer.WriteLine($"\tpublic void Dispose()");
                    writer.WriteLine("\t{");
                    writer.WriteLine("\t\tif (_self != null)");
                    writer.WriteLine("\t\t{");
                    writer.WriteLine("\t\t\tRelease();");
                    writer.WriteLine("\t\t\t_self = null;");
                    writer.WriteLine("\t\t}");
                    writer.WriteLine("\t\tCefObjectTracker.Untrack(this);");
                    writer.WriteLine("\t\tGC.SuppressFinalize(this);");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    writer.WriteLine("\tinternal void AddRef()");
                    writer.WriteLine("\t{");
                    writer.WriteLine($"\t\t_self->_base._add_ref(&_self->_base);");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    writer.WriteLine("\tinternal bool Release()");
                    writer.WriteLine("\t{");
                    writer.WriteLine($"\t\treturn _self->_base._release(&_self->_base) != 0;");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    writer.WriteLine("\tinternal bool HasOneRef");
                    writer.WriteLine("\t{");
                    writer.WriteLine($"\t\tget {{ return _self->_base._has_one_ref(&_self->_base) != 0; }}");
                    writer.WriteLine("\t}");
                    writer.WriteLine();

                    writer.WriteLine("\tinternal bool HasAtLeastOneRef");
                    writer.WriteLine("\t{");
                    writer.WriteLine($"\t\tget {{ return _self->_base._has_at_least_one_ref(&_self->_base) != 0; }}");
                    writer.WriteLine("\t}");
                    writer.WriteLine();
                }

                writer.WriteLine($"\tinternal {maybeNewKeyword}{iname}* ToNative()");
                writer.WriteLine("\t{");
                if (isRefCounted)
                    writer.WriteLine("\t\tAddRef();");
                writer.WriteLine($"\t\treturn {selfAccessor};");
                writer.WriteLine("\t}");

                writer.WriteLine($"\tinternal {maybeNewKeyword}{iname}* GetSelf()");
                writer.WriteLine("\t{");
                writer.WriteLine($"\t\treturn {selfAccessor};");
                writer.WriteLine("\t}");

                foreach (var staticFunc in FilterAndSortFunctionsByApiVersion(cls.StaticFunctions))
                {
                    writer.WriteLine();
                    var sw = new StringWriter();
                    if (TryWriteManagedToUnmanagedMethod(sw, cls, staticFunc))
                    {
                        writer.Write(sw);
                    }
                    else
                    {
                        writer.WriteLine($"\t// Failed to marshal static method {staticFunc.Name}");
                    }
                }

                foreach (var func in FilterAndSortFunctionsByApiVersion(cls.VirtualFunctions))
                {
                    writer.WriteLine();
                    var sw = new StringWriter();
                    if (TryWriteManagedToUnmanagedMethod(sw, cls, func))
                    {
                        writer.Write(sw);
                    }
                    else
                    {
                        writer.WriteLine($"\t// Failed to marshal method {func.Name}");
                    }
                }

                writer.WriteLine("}");
            }
        }

        public void GenerateVersionFile(TextWriter writer)
        {
            WriteHeader(writer);

            writer.WriteLine("using System;");
            writer.WriteLine("using System.Diagnostics.CodeAnalysis;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLine();

            writer.WriteLine("namespace Xilium.CefGlue.Interop;");
            writer.WriteLine();

            writer.WriteLine("internal static unsafe partial class libcef");
            writer.WriteLine("{");
            writer.WriteLine($"\tpublic const string CEF_VERSION = {parser.VersionProperties["CEF_VERSION"]};");
            writer.WriteLine($"\tpublic const int CEF_VERSION_MAJOR = {parser.VersionProperties["CEF_VERSION_MAJOR"]};");
            writer.WriteLine($"\tpublic const int CEF_COMMIT_NUMBER = {parser.VersionProperties["CEF_COMMIT_NUMBER"]};");
            writer.WriteLine($"\tpublic const string CEF_COMMIT_HASH = {parser.VersionProperties["CEF_COMMIT_HASH"]};");
            writer.WriteLine();
            writer.WriteLine($"\tpublic const int CHROME_VERSION_MAJOR = {parser.VersionProperties["CHROME_VERSION_MAJOR"]};");
            writer.WriteLine($"\tpublic const int CHROME_VERSION_MINOR = {parser.VersionProperties["CHROME_VERSION_MINOR"]};");
            writer.WriteLine($"\tpublic const int CHROME_VERSION_BUILD = {parser.VersionProperties["CHROME_VERSION_BUILD"]};");
            writer.WriteLine($"\tpublic const int CHROME_VERSION_PATCH = {parser.VersionProperties["CHROME_VERSION_PATCH"]};");
            writer.WriteLine();
            writer.WriteLine($"\tpublic const int CEF_API_VERSION = {targetApiVersion};");
            writer.WriteLine($"\tpublic const string CEF_API_HASH_PLATFORM_WIN = \"{parser.ApiHashWindows[targetApiVersion]}\";");
            writer.WriteLine($"\tpublic const string CEF_API_HASH_PLATFORM_MACOS = \"{parser.ApiHashMacOS[targetApiVersion]}\";");
            writer.WriteLine($"\tpublic const string CEF_API_HASH_PLATFORM_LINUX = \"{parser.ApiHashLinux[targetApiVersion]}\";");
            writer.WriteLine("}");
        }
    }
}
